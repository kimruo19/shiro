            <!DOCTYPE html>
            <html lang="en">

            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Copy Text Buttons</title>
                <style>
                    button {
                        margin: 5px;
                    }

                    body {
                        background-color: black;
                        /* Light gray background */
                        font-family: Arial, sans-serif;
                        text-align: center;
                    }

                    button {
                        margin: 10px;
                        padding: 10px;
                        font-size: 16px;
                        background-color: DimGray;
                        /* Light gray button background */
                        border: 1px solid #560b0b;
                        /* Dark gray border */
                        cursor: pointer;
                    }

                    button:hover {
                        background-color: #ccc;
                    /* Slightly darker background on hover */
                    }

                </style>
            </head>

            <body>

                <button onclick="copyText(text1)"> 1(A)  Real-Time Processing and Object Detection</button>
                <button onclick="copyText(text2)"> 1(B)	 Gray Scale Conversion</button>
                <button onclick="copyText(text3)"> 1(C)  Edge detection</button>
                <button onclick="copyText(text4)"> 1(D)	Face detection</button>
                <button onclick="copyText(text5)"> 1(E)	Image Cropping and Mouse Events </button>
                <button onclick="copyText(text6)"> 1(F)	Save the image</button>
                <button onclick="copyText(text7)"> 2 - Multicolor Object Tracking </button>
                <button onclick="copyText(text8)"> 3 - Real Time Doc Scanners</button>
                <button onclick="copyText(text9)"> 4 - Virtual drawing using finger tracking (only green and blue)</button>
                <button onclick="copyText(text10)">5 (A) Multi-Face and object Detection(Group Photo-classify girls and boys )</button>
                <button onclick="copyText(text11)">5 (B) Group Photo-with Person name Detection</button>
                <button onclick="copyText(text12)">5 (C)  Detect and label common object(like eraser,scale,pencil) in a static image using opencv</button>
                <button onclick="copyText(text13)">6 - Write a program use PYOpenGL and GLUT TO draw simple triangle</button>
                <button onclick="copyText(text14)">7 - Write a program use PYOpenGL and GLUT TO draw simple square</button>
                <button onclick="copyText(text15)">8 - Write a program with PYOpenGL to draw 3d cubes</button>
                
                
                <p id="copiedMsg"></p>
                <script>
                    var text1 = `#1A_Image Capture Real-Time Processing and Object Detection

cmd- pip install opencv-python 

import cv2

img = cv2.imread("input.png")   


if img is None:
    print("Image not found!")
else:
    cv2.imshow("Captured Image", img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()


                `;


                    var text2 = `# 1B_GrayScaleConversion

cmd: pip install opencv-python 

import cv2
img = cv2.imread("input.png")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
cv2.imshow("Original Image", img)
cv2.imshow("Gray Image", gray)
cv2.waitKey(0)
cv2.destroyAllWindows()

            `;


                    var text3 = ` #1C_Edge detection

cmd: pip install opencv-python

import cv2

# Load image
img = cv2.imread("input.png")

# Convert to grayscale (edge detection works on gray images)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply Canny Edge Detection
edges = cv2.Canny(gray, 100, 200)

# Display results
cv2.imshow("Original Image", img)
cv2.imshow("Gray Image", gray)
cv2.imshow("Edge Detection", edges)

cv2.waitKey(0)
cv2.destroyAllWindows()


            `;


                    var text4 = ` # 1D_Face detection

cmd : pip install opencv-python

import cv2

# Load image
img = cv2.imread("single.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Load Haar cascade using OpenCV's built-in path
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

print("Cascade loaded:", face_cascade.empty())  # Should print False

faces = face_cascade.detectMultiScale(gray, 1.3, 5)

for (x, y, w, h) in faces:
    cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)

cv2.imshow("Face Detection", img)
cv2.waitKey(0)
cv2.destroyAllWindows()


            `;



                    var text5 = `#1E_ImageCropping & Mouse Events

cmd: pip install opencv-python

import cv2

# Load image
img = cv2.imread("single.jpg")

# Function to crop on mouse click
def crop(event, x, y, flags, param):
    global pt1, pt2, cropped
    if event == cv2.EVENT_LBUTTONDOWN:
        pt1 = (x, y)
    elif event == cv2.EVENT_LBUTTONUP:
        pt2 = (x, y)
        cropped = img[pt1[1]:pt2[1], pt1[0]:pt2[0]]
        cv2.imshow("Cropped Image", cropped)

# Initialize
pt1 = pt2 = (0,0)
cropped = None

cv2.namedWindow("Image")
cv2.setMouseCallback("Image", crop)

cv2.imshow("Image", img)
cv2.waitKey(0)
cv2.destroyAllWindows()



            `;


                    var text6 = ` #1F_Save Cropped image

cmd: install opencv-python

import cv2
# Load image
img = cv2.imread("single.jpg")

# Function to crop and save on mouse
def crop(event, x, y, flags, param):
    global pt1, pt2, cropped
    if event == cv2.EVENT_LBUTTONDOWN:
        pt1 = (x, y)
    elif event == cv2.EVENT_LBUTTONUP:
        pt2 = (x, y)
        cropped = img[pt1[1]:pt2[1], pt1[0]:pt2[0]]
        cv2.imshow("Cropped Image", cropped)
        cv2.imwrite("cropped_image.png", cropped)  # Save automatically
        print("Cropped image saved as 'cropped_image.png'")

# Initialize
pt1 = pt2 = (0,0)
cropped = None

cv2.namedWindow("Image")
cv2.setMouseCallback("Image", crop)

cv2.imshow("Image", img)
cv2.waitKey(0)
cv2.destroyAllWindows()

                    

            `;


                    var text7 = `# 2_MulticlrObjectTracking

cmd: pip install opencv-python

import cv2
import numpy as np

# Load image
img = cv2.imread("person.jpg")

# Convert to HSV color space (better for color detection)
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Define color ranges in HSV
# Example: Red, Green, Blue
colors = {
    "Red": ([0, 120, 70], [10, 255, 255]),
    "Green": ([36, 50, 70], [89, 255, 255]),
    "Blue": ([94, 80, 2], [126, 255, 255])
}

# Detect and mark each color
for color_name, (lower, upper) in colors.items():
    lower = np.array(lower)
    upper = np.array(upper)
    
    # Create mask for this color
    mask = cv2.inRange(hsv, lower, upper)
    
    # Find contours
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area > 500:  # filter small areas
            x, y, w, h = cv2.boundingRect(cnt)
            cv2.rectangle(img, (x, y), (x+w, y+h), (0,255,0), 2)
            cv2.putText(img, color_name, (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)

# Show result
cv2.imshow("Multicolor Tracking", img)
cv2.waitKey(0)
cv2.destroyAllWindows()


            `;


                    var text8 = `# 3_RealTimeDocScanners

cmd: pip install opencv-python 

import cv2
import numpy as np
import os
import datetime
import time
 
# Create save folder if it doesn't exist
SAVE_DIR = "scanned_documents"
os.makedirs(SAVE_DIR, exist_ok=True)
 
# Camera setup
cap = cv2.VideoCapture(0)
cap.set(3, 640)
cap.set(4, 480)
 
print("Hold your book clearly in the frame")
print("ESC to exit, 'm' to manually crop with mouse")
 
drawing = False
manual_pts = []
last_auto_save_time = 0
AUTO_SAVE_INTERVAL = 5  # seconds between auto-saves
 
def reorder_points(pts):
    pts = pts.reshape((4, 2))
    new_pts = np.zeros((4, 2), dtype=np.float32)
    add = pts.sum(1)
    diff = np.diff(pts, axis=1)
    new_pts[0] = pts[np.argmin(add)]
    new_pts[2] = pts[np.argmax(add)]
    new_pts[1] = pts[np.argmin(diff)]
    new_pts[3] = pts[np.argmax(diff)]
    return new_pts
 
def get_warp(image, points, w=600, h=800):
    points = reorder_points(points)
    dest = np.array([[0, 0], [w, 0], [w, h], [0, h]], dtype=np.float32)
    matrix = cv2.getPerspectiveTransform(points, dest)
    warped = cv2.warpPerspective(image, matrix, (w, h))
    return warped
 
def draw_manual(event, x, y, flags, param):
    global drawing, manual_pts
    if event == cv2.EVENT_LBUTTONDOWN:
        drawing = True
        manual_pts = [(x, y)]
    elif event == cv2.EVENT_LBUTTONUP:
        drawing = False
        manual_pts.append((x, y))
 
while True:
    ret, frame = cap.read()
    if not ret:
        break
 
    original = frame.copy()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5, 5), 1)
 
    # More robust edge detection using adaptive threshold
    thresh = cv2.adaptiveThreshold(
        gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY,
        11, 2)
    edges = cv2.Canny(thresh, 50, 150)
 
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = sorted(contours, key=cv2.contourArea, reverse=True)
 
    doc_contour = None
    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < 15000 or area > frame.shape[0] * frame.shape[1] * 0.9:
            continue
        peri = cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
        if len(approx) == 4:
            doc_contour = approx
            break
 
    debug = frame.copy()
    for cnt in contours:
        if cv2.contourArea(cnt) > 15000:
            cv2.drawContours(debug, [cnt], -1, (255, 0, 0), 2)
 
    if doc_contour is not None:
        cv2.drawContours(debug, [doc_contour], -1, (0, 255, 0), 3)
        warped = get_warp(original, doc_contour)
 
        # Post-warp thresholding for cleaner scan
        gray_warped = cv2.cvtColor(warped, cv2.COLOR_BGR2GRAY)
        gray_warped = cv2.GaussianBlur(gray_warped, (5, 5), 0)
        _, scanned = cv2.threshold(gray_warped, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
 
        cv2.imshow("Scanned", scanned)
 
        # Auto-save if enough time has passed
        current_time = time.time()
        if current_time - last_auto_save_time > AUTO_SAVE_INTERVAL:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            file_name = os.path.join(SAVE_DIR, f"auto_scan_{timestamp}.png")
            cv2.imwrite(file_name, scanned)
            print(f"[AUTO-SAVE] Document saved as {file_name}")
            last_auto_save_time = current_time
 
    cv2.imshow("Detected Contours", debug)
 
    # Check for manual crop
    if len(manual_pts) == 2:
        x1, y1 = manual_pts[0]
        x2, y2 = manual_pts[1]
        x_start, x_end = sorted([x1, x2])
        y_start, y_end = sorted([y1, y2])
        manual_crop = original[y_start:y_end, x_start:x_end]
        if manual_crop.shape[0] > 0 and manual_crop.shape[1] > 0:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            manual_file = os.path.join(SAVE_DIR, f"manual_scan_{timestamp}.png")
            cv2.imshow("Manual Crop", manual_crop)
            cv2.imwrite(manual_file, manual_crop)
            print(f"[MANUAL SAVE] Manual crop saved as {manual_file}")
            manual_pts = []
 
    key = cv2.waitKey(10) & 0xFF
    if key == ord('m'):
        print("Click and drag to draw cropping box manually...")
        cv2.setMouseCallback("Detected Contours", draw_manual)
    elif key == 27:
        break
 
    time.sleep(0.01)  # Slight delay to reduce CPU usage
 
cap.release()
cv2.destroyAllWindows()


OR (Static code 2)

cmd: py -m pip install pymupdf
or pip install pymupdf
     m pip install opencv-python


import fitz  # PyMuPDF
import cv2
import numpy as np

pdf = fitz.open("252611101100001.pdf")
page = pdf[0]  # first page
pix = page.get_pixmap()

img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, 3)

cv2.imshow("PDF Page", img)
cv2.waitKey(0)
cv2.destroyAllWindows()



            `;


                    var text9 = `# 4_Virtual Drawing using finger tracking 

cmd:
pip install opencv-python 
pip install opencv-python mediapipe
or
pip install mediapipe --user

import cv2
import mediapipe as mp

# Initialize MediaPipe Hand Detector
mp_hands = mp.solutions.hands
mp_draw = mp.solutions.drawing_utils

hands = mp_hands.Hands(max_num_hands=1)
cap = cv2.VideoCapture(0)

# Canvas for drawing
canvas = None

while True:
    success, frame = cap.read()
    if not success:
        break

    frame = cv2.flip(frame, 1)

    # Create canvas first time
    if canvas is None:
        canvas = frame.copy() * 0

    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = hands.process(rgb)

    if results.multi_hand_landmarks:
        hand = results.multi_hand_landmarks[0]

        # Get index finger tip: landmark 8
        h, w, c = frame.shape
        x = int(hand.landmark[8].x * w)
        y = int(hand.landmark[8].y * h)

        # Draw circle on fingertip
        cv2.circle(frame, (x, y), 8, (0, 0, 255), -1)

        # Draw on canvas
        cv2.circle(canvas, (x, y), 8, (0, 0, 255), -1)

        mp_draw.draw_landmarks(frame, hand, mp_hands.HAND_CONNECTIONS)

    # Combine drawing with camera
    output = cv2.add(frame, canvas)

    cv2.imshow("Virtual Drawing", output)

    if cv2.waitKey(1) & 0xFF == 27:  # ESC to exit
        break

cap.release()
cv2.destroyAllWindows()


OR (Static code)

cmd install:-m pip install opencv-python 

import cv2
import numpy as np

# Load image
img = cv2.imread("C:/Users/Administrator/Downloads/input.png")
canvas = np.zeros_like(img)

# Convert to HSV
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Masks for green and blue
green_mask = cv2.inRange(hsv, np.array([40,70,70]), np.array([80,255,255]))
blue_mask = cv2.inRange(hsv, np.array([100,150,50]), np.array([140,255,255]))

# Draw single dot for green
green_points = np.column_stack(np.where(green_mask > 0))
if len(green_points) > 0:
    y, x = green_points[0]  # pick first point (tip)
    cv2.circle(canvas, (x, y), 20, (0,255,0), -1)

# Draw single dot for blue
blue_points = np.column_stack(np.where(blue_mask > 0))
if len(blue_points) > 0:
    y, x = blue_points[0]
    cv2.circle(canvas, (x, y), 20, (255,0,0), -1)

# Merge and show
output = cv2.addWeighted(img, 0.7, canvas, 0.7, 0)
cv2.imshow("Virtual Drawing", output)
cv2.waitKey(0)
cv2.destroyAllWindows()



            `;

                    var text10 = `#5(A) 

            `;


                    var text11 = `# 5 (B) 

            `;


                    var text12 = `# 5 (C) 


            `;



                    var text13 = `# 6_Triangle-PYOpenGL & GLUT 

#Write a program use PYOpenGL and GLUT TO draw simple triangle

CMD: 
pip install pygame
pip install PyOpenGL
pip install PyOpenGL_accelerate


            `;


                    var text14 = `#7_Square-PYOpenGL & GLUT 
#Write a program use PYOpenGL and GLUT TO draw simple square

CMD: 
pip install pygame
pip install PyOpenGL
pip install PyOpenGL_accelerate

from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *

w,h = (500,500)

def square():
    glBegin(GL_QUADS)
    glVertex2f(100,100)
    glVertex2f(200,100)
    glVertex2f(200,200)
    glVertex2f(100,200)
    glEnd()

def iterate():
    glViewport(0,0,500,500)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    glOrtho(0.0,500,0.0,500,0.0,1.0)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

def showscreen():
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT) #Clear Screen
    glLoadIdentity()
    iterate()
    glColor(1.0,0.0,3.0)
    square()
    glutSwapBuffers()

glutInit() #Initializing window
glutInitDisplayMode(GLUT_RGBA|GLUT_DOUBLE|GLUT_DEPTH) #RGB Mode
glutInitWindowSize(400,400) #Window size
glutInitWindowPosition(100,100) #Window position
glutCreateWindow(b'PyOpen Example - Surabhi Maydeo') #window name
glutDisplayFunc(showscreen) # set display call back
glutMainLoop() # start event loop

            `;


                    var text15 = `#8_3DCube-PYOpenGl
 
#Write a program with PYOpenGL to draw 3d cubes

CMD: 
pip install pygame
pip install PyOpenGL
pip install PyOpenGL_accelerate

import pygame
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GLU import *

# Vertices
v = (
    (1, -1, -1),
    (1, 1, -1),
    (-1, 1, -1),
    (-1, -1, -1),
    (1, -1, 1),
    (1, 1, 1),
    (-1, -1, 1),
    (-1, 1, 1)
)

# Edges
E = (
    (0, 1), (0, 3), (0, 4),
    (2, 1), (2, 3), (2, 7),
    (6, 3), (6, 4), (6, 7),
    (5, 1), (5, 4), (5, 7)
)

def cube():
    glBegin(GL_LINES)
    for e1 in E:
        for v1 in e1:  # FIXED
            glVertex3fv(v[v1])
    glEnd()
def main():
    pygame.init()
    display = (800, 600)
    pygame.display.set_mode(display, DOUBLEBUF | OPENGL)
    # Setup Projection
    glMatrixMode(GL_PROJECTION)
    gluPerspective(45, (display[0] / display[1]), 0.1, 50.0)
    # Switch to ModelView
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    glTranslatef(0.0, 0.0, -5)
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:  # FIXED
                pygame.quit()
                quit()

        # Rotate cube
        glRotatef(1, 3, 1, 1)

        # Clear screen and depth buffer
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        cube()

        pygame.display.flip()
        pygame.time.wait(20)
main()

            `;


                   

            function copyText(text) {
                navigator.clipboard.writeText(text).then(function () {
                    document.getElementById('copiedMsg').innerHTML = "Text Copied"
                }).catch(function (err) {
                    console.error('Unable to copy text', err);
                });
            }
            </script>

            </body>

            </html>
